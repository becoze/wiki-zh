# 2. ⭐数组的赋值

📌 数组的赋值也遵从自动类型转换。

## 数组的自动类型转换

✅ 同类型 (float -> float)

```java
float[] name = {1.0, 2f, 3F};
```

✅ 高精度转低精度 (double -> int)

```java
double[] name = {1.0, 2.0, 3};
```

❌ 低精度不能转高精度 (int --x> double)

```java
int[] name = {1, 2, 3.0};
```

❌ 类型不匹配 (int --x> String)

```java
int[] name = {1, 2, "hello"};
```



## 数组的默认值：

数值内元素的默认值和基本数据类型一样。

|  |  | 默认值 |
| --- | --- | --- |
| 整数 | byte; short; int; long | 0 |
| 浮点 | float; double  | 0.0 |
| 字符 | char | ' '  \ u0000 |
| 布尔 | boolean | false |
| 字符串 | String | null |



## ⭐数组赋值机制

⚠️ 值传递 和 引用传递 都是把内存栈上面的值赋给其他变量。
  但值传递是独立的具体的值；
  而引用传递是内存地址，指向同一块堆空间。

![Untitled](2%20%E2%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%20f20a1b5cbf6c4c7f993cba97fdbb82bd/Untitled.png)

### 值传递


📌 基本数据类型赋值通常为值传递，赋值方式为值拷贝（传递数的当前的值）

```java
int n1 = 10;     // n1 = 10
int n2 = n1;     // n1 = 10; n2 = 10;
n2 = 30;         // n1 = 10; n2 = 30;
n1 = 0;          // n1 = 0; n2 = 30;
```

### 引用传递 


📌 数组在默认情况下是引用传递，赋的值是地址。地址指向的内存空间只有一块。（传递内存地址）

```java
int[] arr1 = {1,2,3};     // arr1 = {1,2,3}
int[] arr2 = arr1;        // arr2 -> 0x12345 <- arr1 
arr2[0] = 50;             // arr1 = {50,2,3}; 
```

arr1的地址值赋给了arr2，代表arr1和arr2都指向同一个数组。也可以说这时arr1和arr2公用同一个数组。

arr2改变了数组，也可以通过arr1观察到。（并不是"影响"arr1，本质它们共用同一块内存空间）