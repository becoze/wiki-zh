# 191. 位 1 的个数

问题链接: [LeetCode - 191. 位 1 的个数 (简单)](https://leetcode.cn/problems/number-of-1-bits/)

相关标签：位运算

# Think

**移动n**

使用 >>> 无符号位移去移动n，判断最后一位是否为1，直到遍历整个n（n=0）。

```java
n = 00000000000000000000000000001011 ->
                                   ^
                                监测点
```

**移动pointer**

使用 << 位移去移动pointer（也就是1），判断当前一位是否为1，直到遍历整个n（32次）。

```java
n = 00000000000000000000000000001011 
                                <- ^
                                监测点
```

# Key

**n&1;** 通过 n&1 返回n的最后一位，在这题时可以 **“判断当前一位是否为1”**。

&：按位与 Bitwise AND：当两个数同位都为1，结果为1，否则为0。

```java
n = 00000000000000000000000000001011
1 = 00000000000000000000000000000001
n&1=00000000000000000000000000000001
```

通过n >>> 向右整个移动n

```java
n>>>00000000000000000000000000000101
n = 00000000000000000000000000000101
1 = 00000000000000000000000000000001
n&1=00000000000000000000000000000001
```

# Answer

**移动n (>>>n)**

```java
public int hammingWeight(int n) {
  int count = 0;
  while (n != 0) {
      res += n & 1;  // if(n & 1 == 1){ res ++ }
      n >>>= 1;
  }
  return count;
}
```

**移动pointer (<<i)**

```java
public int hammingWeight(int n) {
  int count = 0;
  for(int i = 0; i < 32; i++) {
      if( (n & (1 << i)) != 0 ){
					count ++;
			}
  }
  return count;
}
```