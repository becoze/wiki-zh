# 191. 位 1 的个数

# 问题

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用`二进制补码`记法来表示有符号整数。因此，在 **示例 3** 中，输入表示有符号整数 `-3`。

**示例 1：**

```
输入：n = 00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：n = 00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：n = 11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

 

> 问题链接: [LeetCode - 191. 位 1 的个数 (简单)](https://leetcode.cn/problems/number-of-1-bits/)
>
> 相关标签：位运算

# 思路

**移动n**

使用 >>> 无符号位移去移动n，判断最后一位是否为1，直到遍历整个n（n=0）。

```java
n = 00000000000000000000000000001011 ->
                                   ^
                                监测点
```

**移动pointer**

使用 << 位移去移动pointer（也就是1），判断当前一位是否为1，直到遍历整个n（32次）。

```java
n = 00000000000000000000000000001011 
                                <- ^
                                监测点
```

# 关键

**n&1;** 通过 n&1 返回n的最后一位，在这题时可以 **“判断当前一位是否为1”**。

&：按位与 Bitwise AND：当两个数同位都为1，结果为1，否则为0。

```java
n = 00000000000000000000000000001011
1 = 00000000000000000000000000000001
n&1=00000000000000000000000000000001
```

通过n >>> 向右整个移动n

```java
n>>>00000000000000000000000000000101
n = 00000000000000000000000000000101
1 = 00000000000000000000000000000001
n&1=00000000000000000000000000000001
```

# 代码

**移动n (>>>n)**

```java
public int hammingWeight(int n) {
  int count = 0;
  while (n != 0) {
      res += n & 1;  // if(n & 1 == 1){ res ++ }
      n >>>= 1;
  }
  return count;
}
```

**移动pointer (<<i)**

```java
public int hammingWeight(int n) {
  int count = 0;
  for(int i = 0; i < 32; i++) {
      if( (n & (1 << i)) != 0 ){
					count ++;
			}
  }
  return count;
}
```